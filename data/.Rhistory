test
require(swim)
data(blueshark)
test = fitSHMMM(blueshark, 6)
test
test[[1]]fn()
test[[1]]$fn()
test[[1]]$gr()
test$obj$gr()
names(test) = c("obj", "srep", "states")
head(test)
test$obj$fn()
test$obj$fn(0)
test$obj$env$parList()
q()
require(swim)
example(fitSHMMM)
?cat
cat("Call:\n")
cat("\mCall:\n")
cat("\nCall:\n")
?printCoefmat
cat("\n Call")
require(swim)
data(blueshark)
head(blueshark)
test = fitSHMMM(blueshark, 6)
test
summary(test)
summary.swim(test)
summary.swim
fitSHMMM
summary
fitSHMMM = function(data, ts) UseMethod("swim"){
#data input, n X 2 vector
#ts timestep (hours)
#interpolate the data to regular time intervals
delta = ts*60*60 #time step in seconds
t0 = data$date[1] #first time step
tT = data$date[length(data$date)] #the final date time
t = seq(t0, tT, by=delta) #all the time values for interpolation
iLoc <- cbind(approx(data$date, data$lon, xout = t)$y,
approx(data$date, data$lat, xout = t)$y)
#load TMB
requireNamespace("TMB", quietly=TRUE)
#compiling the c++ function
#compile("SHMMM.cpp", flags="-Wno-unused-variable")
#Loading the compiled c++ file into the R environment.
#dyn.load(dynlib("SHMMM")) #need to fix this for PCs (or non-macs)
#create a list of input data. The order must match the order in the c++ file!
space = 0:1
mu = c(0.5,0.5)
dats <- list(x = t(iLoc),
b=as.integer(space),
stateSpace=factor(space),
initDist=as.double(mu))
#create a list of input parameters. Again, order matters!
parameters <- list(logitTheta1=0, logitTheta2=0,
logitGamma1=0, logitGamma2=0,
logSdlat=0, logSdlon=0,
logA=matrix(log(1),ncol=1,nrow=2))
#Then make an objective function, the negative log likelihood to minimize.
obj <- MakeADFun(dats,parameters,
DLL="swim")
#Now we can pass the objective function and its derivatives into any regular R optimizer.
#We are using nlminb.
opt <- nlminb(obj$par,obj$fn,obj$gr)
#calculate the parameter results
srep <- summary(sdreport(obj))
#calculate the latent behavioral states with the Viterbi algorithm
states = obj$report()$states
#return the object and the parameter results
rslts <- list(obj, srep, states)
names(rslts) <- c("obj", "parms", "states") #name them again
class(rslts) <- "swim" #set class for later (summary, print, and plot functions)
return(rslts)
}
fitSHMMM = function(data, ts) UseMethod("swim")
{
#data input, n X 2 vector
#ts timestep (hours)
#interpolate the data to regular time intervals
delta = ts*60*60 #time step in seconds
t0 = data$date[1] #first time step
tT = data$date[length(data$date)] #the final date time
t = seq(t0, tT, by=delta) #all the time values for interpolation
iLoc <- cbind(approx(data$date, data$lon, xout = t)$y,
approx(data$date, data$lat, xout = t)$y)
#load TMB
requireNamespace("TMB", quietly=TRUE)
#compiling the c++ function
#compile("SHMMM.cpp", flags="-Wno-unused-variable")
#Loading the compiled c++ file into the R environment.
#dyn.load(dynlib("SHMMM")) #need to fix this for PCs (or non-macs)
#create a list of input data. The order must match the order in the c++ file!
space = 0:1
mu = c(0.5,0.5)
dats <- list(x = t(iLoc),
b=as.integer(space),
stateSpace=factor(space),
initDist=as.double(mu))
#create a list of input parameters. Again, order matters!
parameters <- list(logitTheta1=0, logitTheta2=0,
logitGamma1=0, logitGamma2=0,
logSdlat=0, logSdlon=0,
logA=matrix(log(1),ncol=1,nrow=2))
#Then make an objective function, the negative log likelihood to minimize.
obj <- MakeADFun(dats,parameters,
DLL="swim")
#Now we can pass the objective function and its derivatives into any regular R optimizer.
#We are using nlminb.
opt <- nlminb(obj$par,obj$fn,obj$gr)
#calculate the parameter results
srep <- summary(sdreport(obj))
#calculate the latent behavioral states with the Viterbi algorithm
states = obj$report()$states
#return the object and the parameter results
rslts <- list(obj, srep, states)
names(rslts) <- c("obj", "parms", "states") #name them again
class(rslts) <- "swim" #set class for later (summary, print, and plot functions)
return(rslts)
}
rm(list=ls())
fitSHMMM = function(data, ts) UseMethod("swim")
{
#data input, n X 2 vector
#ts timestep (hours)
#interpolate the data to regular time intervals
delta = ts*60*60 #time step in seconds
t0 = data$date[1] #first time step
tT = data$date[length(data$date)] #the final date time
t = seq(t0, tT, by=delta) #all the time values for interpolation
iLoc <- cbind(approx(data$date, data$lon, xout = t)$y,
approx(data$date, data$lat, xout = t)$y)
#load TMB
requireNamespace("TMB", quietly=TRUE)
#compiling the c++ function
#compile("SHMMM.cpp", flags="-Wno-unused-variable")
#Loading the compiled c++ file into the R environment.
#dyn.load(dynlib("SHMMM")) #need to fix this for PCs (or non-macs)
#create a list of input data. The order must match the order in the c++ file!
space = 0:1
mu = c(0.5,0.5)
dats <- list(x = t(iLoc),
b=as.integer(space),
stateSpace=factor(space),
initDist=as.double(mu))
#create a list of input parameters. Again, order matters!
parameters <- list(logitTheta1=0, logitTheta2=0,
logitGamma1=0, logitGamma2=0,
logSdlat=0, logSdlon=0,
logA=matrix(log(1),ncol=1,nrow=2))
#Then make an objective function, the negative log likelihood to minimize.
obj <- MakeADFun(dats,parameters,
DLL="swim")
#Now we can pass the objective function and its derivatives into any regular R optimizer.
#We are using nlminb.
opt <- nlminb(obj$par,obj$fn,obj$gr)
#calculate the parameter results
srep <- summary(sdreport(obj))
#calculate the latent behavioral states with the Viterbi algorithm
states = obj$report()$states
#return the object and the parameter results
rslts <- list(obj, srep, states)
names(rslts) <- c("obj", "parms", "states") #name them again
class(rslts) <- "swim" #set class for later (summary, print, and plot functions)
return(rslts)
}
?UseMethod
mean
mean.numeri
mean.numeric
methods(summary)
q()
data(blueshark)
require(swim)
data(blueshark)
ls
fitSHMMM(blueshark)
fitSHMMM(blueshark,6)
test = fitSHMMM(blueshark,6)
summary(test)
q()
require(swim)
data(blueshark)
swim(blueshark, 6)
test = swim(blueshark, 6)
summary(test)
#Get the Wald tests and the Confidence intervals for the parameter values
summary.swim <- function(object, ...){
#Summary (Z statistics)
Ztest = as.data.frame(object$parms,
row.names= c("logitTheta1", "logitTheta2",
"logitGamma1", "logitGamma2",
"logSdlat", "logSdlon",
"logA11", "logA21",
"theta1", "theta2",
"gamma1", "gamma2",
"sdLat", "sdLon",
"a11", "a21", "a12", "a22"))
Ztest$z.val = Ztest[,1]/Ztest[,2]
Ztest$p.val = 2*pnorm(-abs(Ztest$z.val))
#Confidence Intervals
CIs = as.data.frame(object$parms,
row.names= c("logitTheta1", "logitTheta2",
"logitGamma1", "logitGamma2",
"logSdlat", "logSdlon",
"logA11", "logA21",
"theta1", "theta2",
"gamma1", "gamma2",
"sdLat", "sdLon",
"a11", "a21", "a12", "a22"))
CIs$lower95 = CIs[,1] - 2*CIs[,2]
CIs$upper95 = CIs[,1] + 2*CIs[,2]
CIs
sum.obj <- list(Ztest, CIs)
names(sum.obj) <- c("Ztest", "CIs")
sum.obj <- class("summary.swim")
}
summary(test)
rm(print.summary.swim)
rm(print.summary.swim())
q()
require(swim)
data(blueshark)
test = swim(blueshark, 6)
summary(test)
q()
require(swim)
data(blueshark)
test = swim(blueshark, 6)
summary(test)
q()
require(swim)
data(blueshark)
test = swim(blueshark, 6)
summary(test)
summary.swim <- function(object, ...){
#Summary (Z statistics)
Ztest = as.data.frame(object$parms,
row.names= c("logitTheta1", "logitTheta2",
"logitGamma1", "logitGamma2",
"logSdlat", "logSdlon",
"logA11", "logA21",
"theta1", "theta2",
"gamma1", "gamma2",
"sdLat", "sdLon",
"a11", "a21", "a12", "a22"))
Ztest$z.val = Ztest[,1]/Ztest[,2]
Ztest$p.val = 2*pnorm(-abs(Ztest$z.val))
#Confidence Intervals
CIs = as.data.frame(object$parms,
row.names= c("logitTheta1", "logitTheta2",
"logitGamma1", "logitGamma2",
"logSdlat", "logSdlon",
"logA11", "logA21",
"theta1", "theta2",
"gamma1", "gamma2",
"sdLat", "sdLon",
"a11", "a21", "a12", "a22"))
CIs$lower95 = CIs[,1] - 2*CIs[,2]
CIs$upper95 = CIs[,1] + 2*CIs[,2]
CIs
sum <- list(Ztest, CIs)
names(sum) <- c("Ztest", "CIs")
sum <- class("summary.swim")
sum.obj
}
summary(test)
summary.swim <- function(object, ...){
#Summary (Z statistics)
Ztest = as.data.frame(object$parms,
row.names= c("logitTheta1", "logitTheta2",
"logitGamma1", "logitGamma2",
"logSdlat", "logSdlon",
"logA11", "logA21",
"theta1", "theta2",
"gamma1", "gamma2",
"sdLat", "sdLon",
"a11", "a21", "a12", "a22"))
Ztest$z.val = Ztest[,1]/Ztest[,2]
Ztest$p.val = 2*pnorm(-abs(Ztest$z.val))
#Confidence Intervals
CIs = as.data.frame(object$parms,
row.names= c("logitTheta1", "logitTheta2",
"logitGamma1", "logitGamma2",
"logSdlat", "logSdlon",
"logA11", "logA21",
"theta1", "theta2",
"gamma1", "gamma2",
"sdLat", "sdLon",
"a11", "a21", "a12", "a22"))
CIs$lower95 = CIs[,1] - 2*CIs[,2]
CIs$upper95 = CIs[,1] + 2*CIs[,2]
CIs
sum <- list(Ztest, CIs)
names(sum) <- c("Ztest", "CIs")
sum <- class("summary.swim")
sum
}
summary(test)
test
object = test
Ztest = as.data.frame(object$parms,
row.names= c("logitTheta1", "logitTheta2",
"logitGamma1", "logitGamma2",
"logSdlat", "logSdlon",
"logA11", "logA21",
"theta1", "theta2",
"gamma1", "gamma2",
"sdLat", "sdLon",
"a11", "a21", "a12", "a22"))
Ztest
Ztest$z.val = Ztest[,1]/Ztest[,2]
Ztest$p.val = 2*pnorm(-abs(Ztest$z.val))
Ztest
#Confidence Intervals
CIs = as.data.frame(object$parms,
row.names= c("logitTheta1", "logitTheta2",
"logitGamma1", "logitGamma2",
"logSdlat", "logSdlon",
"logA11", "logA21",
"theta1", "theta2",
"gamma1", "gamma2",
"sdLat", "sdLon",
"a11", "a21", "a12", "a22"))
CIs$lower95 = CIs[,1] - 2*CIs[,2]
CIs$upper95 = CIs[,1] + 2*CIs[,2]
CIs
sum <- list(Ztest, CIs)
names(sum) <- c("Ztest", "CIs")
sum <- class("summary.swim")
sum
sum <- list(Ztest, CIs)
sum
names(sum) <- c("Ztest", "CIs")
class(sum) <- "summary.swim"
sum
q()
require(swim)
data(blueshark)
test = swim(blueshark, 6)
summary(test)
cat("Switching Hidden Markov Movement Model: \n")
cat("Switching Hidden Markov Movement Model:\n")
cat("Switching Hidden Markov Movement Model:\n")
cat("\nWald Tests: \n")
q()
require(swim)
data(blueshark)
test = swim(blueshark, 6)
summary(test)
summary(test)[[2]]
printCoefmat(summary(test)[[2]][9:18,-2]), P.values=FALSE)
printCoefmat(summary(test)[[2]][9:18,-2], P.values=FALSE)
print(summary(test)[[2]][9:18,-2])
print(round(summary(test)[[2]][9:18,-2]),4)
print(round(summary(test)[[2]][9:18,-2],4))
printCoefMat
printCoefmat
?printCoefmat
printCoefmat(summary(test)[[2]][9:18,-2], dig.tst = 7)
printCoefmat(summary(test)[[2]][9:18,-2], dig.tst = 8)
printCoefmat(summary(test)[[2]][9:18,-2], dig.tst = 10)
printCoefmat(summary(test)[[2]][9:18,-2], digits = 7, dig.tst = 10)
printCoefmat(summary(test)[[2]][9:18,-2], digits = 3, dig.tst = 10)
print(round(summary(test)[[2]][9:18,-2], 5))
print(round(summary(test)[[2]][9:18,-2], 7))
print(summary(test)[[2]][9:18,-2])
q()
require(swim)
data(blueshark)
test = swim(blueshark, 6)
summary(test)
q()
require(swim)
data(blueshark)
test = swim(blueshark, 6)
test = fitSHMMM(blueshark, 6)
summary(test)
summary(test)[[1]]
require(swim)
data(blueshark)
fitSwim(blueshark, 6)
fitSwim(blueshark, 6)
fitSwim <- function(data, ts, model_type="SHMMM"){
#data input, n X 2 vector
#ts timestep (hours)
#interpolate the data to regular time intervals
delta = ts*60*60 #time step in seconds
t0 = data$date[1] #first time step
tT = data$date[length(data$date)] #the final date time
t = seq(t0, tT, by=delta) #all the time values for interpolation
iLoc <- cbind(approx(data$date, data$lon, xout = t)$y,
approx(data$date, data$lat, xout = t)$y)
#load TMB
requireNamespace("TMB", quietly=TRUE)
#compiling the c++ function
#compile("SHMMM.cpp", flags="-Wno-unused-variable")
#Loading the compiled c++ file into the R environment.
#dyn.load(dynlib("SHMMM")) #need to fix this for PCs (or non-macs)
#create a list of input data. The order must match the order in the c++ file!
space = 0:1
mu = c(0.5,0.5)
dats <- list(x = t(iLoc),
b=as.integer(space),
stateSpace=factor(space),
initDist=as.double(mu))
#create a list of input parameters. Again, order matters!
parameters <- list(logitTheta1=0, logitTheta2=0,
logitGamma1=0, logitGamma2=0,
logSdlat=0, logSdlon=0,
logA=matrix(log(1),ncol=1,nrow=2))
#Then make an objective function, the negative log likelihood to minimize.
obj <- MakeADFun(dats,parameters,
DLL="swim")
#Now we can pass the objective function and its derivatives into any regular R optimizer.
#We are using nlminb.
opt <- nlminb(obj$par,obj$fn,obj$gr)
#calculate the parameter results
srep <- summary(sdreport(obj))
#calculate the latent behavioral states with the Viterbi algorithm
states = obj$report()$states
#return the object and the parameter results
rslts <- list(regData = iLoc, obj=obj, parms=srep, states=states)
class(rslts) <- "swim" #set class for later (summary, print, and plot functions)
return(rslts)
}
fitSwim(blueshark, 6)
require(swim)
data(blueshark)
test = fitSwim(blueshark, 6)
test
summary(test)
summary(test)[[1]]
require(bsam)
plotSSM
test
names(test)
require(swim)
example(fitSwim)
data(blueshark)
test = fitSwim(blueshark, 6)
plot(test)
data = object$regData
object=test
plot(objec)
plot(object)
data = object$regData
states = object$states
plot(data$lat~data$lon, type="o", pch=20, cex=0.7,
col=ifelse(states==2, "blue", "grey"))
data
object$regData
head(object$regData)
class(object$regData)
?data.frame
require(swim)
data(blueshark)
test = fitSwim(blueshark, 6)
plot(test)
require(swim)
data(blueshark)
fitSwim(blueshark, 6)
test = fitSwim(blueshark, 6)
plot(blueshark)
plot(test)
?plot.swim
plot(data[states==1,]$lat~data[states==1,]$lon, type="o", pch=20, cex=0.7, col="grey")
require(swim)
data(blueshark)
test = fitSwim(blueshark, 6)
plot(test)
require(swim)
example(fitSwim)
require(swim)
example(fitSwim)
test
require(rgdal)
?line
test
object = test
setwd("~/Desktop/swim/data")
world <- readOGR(dsn = ".", layer = "ne_10m_land")
xlims = c(min(test$regData$lon)-2, max(test$regData$lon)+2) #longitude
ylims = c(min(test$regData$lat)-2, max(test$regData$lat)+2) #latitude
locs = data.frame(shark$Most.Likely.Longitude, shark$Most.Likely.Latitude)
#make the spatial points data frame to get the location points
locs = data.frame(object$regData$lon, object$regData$lat)
spdf <- SpatialPointsDataFrame(coords = locs, data=locs,
proj4string = CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"))
line = Lines(list(Line(locs)))
sl = SpatialLines(list(line))
line = Lines(list(Line(locs)), ID="path")
sl = SpatialLines(list(line))
#plot everything
plot(world, col="mediumseagreen", xlim=xlims, ylim=ylims, axes=TRUE,
xaxt="n")
plot(sl, add=TRUE, col="grey")
plot(spdf[which(object$states==1),], add=TRUE, pch=20, cex=1, type="o",
col="grey")
plot(spdf[which(object$states==2),], add=TRUE, pch=20, cex=1, type="o",
col="blue")
plot(world, col="mediumseagreen", xlim=xlims, ylim=ylims, axes=TRUE,
xaxt="n")
plot(spdf[which(object$states==1),], add=TRUE, pch=20, cex=0.7, type="o",
col="grey")
plot(spdf[which(object$states==2),], add=TRUE, pch=20, cex=0.7, type="o",
col="blue")
rm(list=ls())
world <- readOGR(dsn = ".", layer = "ne_10m_land")
save.image("shpfiles.rda")
